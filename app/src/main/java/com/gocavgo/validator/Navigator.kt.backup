package com.gocavgo.validator

import android.annotation.SuppressLint
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.VectorDrawable
import android.media.RingtoneManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.LayoutInflater
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.compose.ui.util.fastForEach
import androidx.core.content.ContextCompat
import androidx.core.graphics.createBitmap
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.lifecycle.lifecycleScope
import com.gocavgo.validator.database.DatabaseManager
import com.gocavgo.validator.dataclass.TripResponse
import com.gocavgo.validator.dataclass.TripStatus
import com.gocavgo.validator.network.NetworkMonitor
import com.gocavgo.validator.service.MqttService
import com.gocavgo.validator.trip.TripProgressTracker
import com.gocavgo.validator.nfc.NFCReaderHelper
import com.here.sdk.core.Anchor2D
import com.here.sdk.core.Color
import com.here.sdk.core.GeoCoordinates
import com.here.sdk.core.LanguageCode
import com.here.sdk.core.Location
import com.here.sdk.core.LocationListener
import com.here.sdk.core.engine.AuthenticationMode
import com.here.sdk.core.engine.SDKNativeEngine
import com.here.sdk.core.engine.SDKOptions
import com.here.sdk.core.errors.InstantiationErrorException
import com.here.sdk.location.LocationAccuracy
import com.here.sdk.location.LocationEngine
import com.here.sdk.location.LocationEngineStatus
import com.here.sdk.location.LocationFeature
import com.here.sdk.location.LocationStatusListener
import com.here.sdk.maploader.DownloadRegionsStatusListener
import com.here.sdk.maploader.DownloadableRegionsCallback
import com.here.sdk.maploader.MapDownloader
import com.here.sdk.maploader.MapDownloaderTask
import com.here.sdk.maploader.MapLoaderError
import com.here.sdk.maploader.MapLoaderException
import com.here.sdk.maploader.Region
import com.here.sdk.maploader.RegionId
import com.here.sdk.mapview.ImageFormat
import com.here.sdk.mapview.LineCap
import com.here.sdk.mapview.MapImage
import com.here.sdk.mapview.MapImageFactory
import com.here.sdk.mapview.MapMarker
import com.here.sdk.mapview.MapMeasureDependentRenderSize
import com.here.sdk.mapview.MapPolyline
import com.here.sdk.mapview.MapScheme
import com.here.sdk.mapview.MapView
import com.here.sdk.mapview.RenderSize
import com.here.sdk.navigation.DestinationReachedListener
import com.here.sdk.navigation.DistanceType
import com.here.sdk.navigation.DynamicCameraBehavior
import com.here.sdk.navigation.LocationSimulator
import com.here.sdk.navigation.LocationSimulatorOptions
import com.here.sdk.navigation.Milestone
import com.here.sdk.navigation.MilestoneStatus
import com.here.sdk.navigation.MilestoneStatusListener
import com.here.sdk.navigation.NavigableLocation
import com.here.sdk.navigation.NavigableLocationListener
import com.here.sdk.navigation.Navigator
import com.here.sdk.navigation.RouteDeviation
import com.here.sdk.navigation.RouteDeviationListener
import com.here.sdk.navigation.RouteProgress
import com.here.sdk.navigation.RouteProgressListener
import com.here.sdk.navigation.SafetyCameraWarningListener
import com.here.sdk.navigation.SpeedLimit
import com.here.sdk.navigation.SpeedLimitListener
import com.here.sdk.navigation.SpeedWarningListener
import com.here.sdk.navigation.SpeedWarningStatus
import com.here.sdk.navigation.VisualNavigator
import com.here.sdk.routing.CarOptions
import com.here.sdk.routing.OfflineRoutingEngine
import com.here.sdk.routing.RefreshRouteOptions
import com.here.sdk.routing.Route
import com.here.sdk.routing.RouteHandle
import com.here.sdk.routing.RoutingEngine
import com.here.sdk.routing.RoutingError
import com.here.sdk.routing.RoutingInterface
import com.here.sdk.routing.Waypoint
import com.here.sdk.routing.WaypointType
import com.here.sdk.trafficawarenavigation.DynamicRoutingEngine
import com.here.sdk.trafficawarenavigation.DynamicRoutingEngineOptions
import com.here.sdk.trafficawarenavigation.DynamicRoutingListener
import com.here.sdk.transport.TransportMode
import com.here.time.Duration
import kotlinx.coroutines.launch
import java.io.ByteArrayOutputStream
import java.util.concurrent.TimeUnit
import androidx.core.graphics.toColorInt
import com.gocavgo.validator.dataclass.SavePlaceResponse
import com.gocavgo.validator.dataclass.TripWaypoint

class Navigator : AppCompatActivity() {

    companion object {
        private const val TAG = "Navigator"
        const val EXTRA_TRIP_ID = "trip_id"
        const val EXTRA_SHOW_MAP = "show_map"
        const val EXTRA_IS_SIMULATED = "is_simulated"
        const val EXTRA_NETWORK_CONNECTED = "network_connected"
        const val EXTRA_CONNECTION_TYPE = "connection_type"
        const val EXTRA_IS_METERED = "is_metered"
    }

    private var mapView: MapView? = null
    private var visualNavigator: VisualNavigator? = null
    private var navigator: Navigator? = null
    private var locationSimulator: LocationSimulator? = null
    private var locationEngine: LocationEngine? = null
    private val handler = Handler(Looper.getMainLooper())
    private var offlineSwitchRunnable: Runnable? = null

    // Speed display UI elements
    private var speedValueTextView: android.widget.TextView? = null
    private var speedUnitTextView: android.widget.TextView? = null
    private var speedAccuracyTextView: android.widget.TextView? = null
    private var speedDisplayContainer: android.widget.LinearLayout? = null
    
    // Speed tracking variables
    private var currentSpeedKmh = 0.0
    private var speedAccuracy = 0.0
    private var lastSpeedUpdateTime = 0L
    private val SPEED_UPDATE_INTERVAL = 1000L // Update every 1 second

    private var onlineRoutingEngine: RoutingEngine? = null
    private var offlineRoutingEngine: OfflineRoutingEngine? = null
    private var dynamicRoutingEngine: DynamicRoutingEngine? = null
    private var mapDownloader: MapDownloader? = null
    private var showMap: Boolean = false
    private var isSimulated: Boolean = true
    private val waypointMarkers = mutableListOf<MapMarker>()
    private var routeMapPolyline: MapPolyline? = null

    // Map data management
    private var downloadableRegions = mutableListOf<Region>()
    private val mapDownloaderTasks = mutableListOf<MapDownloaderTask>()

    private var useDynamicRouting: Boolean = false
    private var currentRoute: Route? = null
    private var isMapDataReady = false

    // Trip data
    private var tripResponse: TripResponse? = null
    private lateinit var databaseManager: DatabaseManager
    private var tripProgressTracker: TripProgressTracker? = null
    private var mqttService: MqttService? = null

    private var networkMonitor: NetworkMonitor? = null
    private var isNetworkConnected = false
    private var currentConnectionType = "UNKNOWN"
    private var isConnectionMetered = true
    private var currentUserLocation: Location? = null
    private val markerImageCache = mutableMapOf<Int, MapImage>()
    
    // Headless mode UI elements
    private var currentLocationText: android.widget.TextView? = null
    private var waypointsContainer: android.widget.LinearLayout? = null
    
    // NFC functionality
    private var nfcReaderHelper: NFCReaderHelper? = null
    private val recentBookings = mutableListOf<BookingRecord>()
    private var isDestroyed = false
    private var isShowingBookingConfirmation = false
    private var bookingConfirmationView: android.view.View? = null
    private var confirmationRunnable: Runnable? = null
    private var isProcessingNFC = false
    private var pendingNFCId: String? = null
    
    // Booking data class
    data class BookingRecord(
        val nfcId: String,
        val waypointName: String,
        val timestamp: Long,
        val price: Double
    )
    
    // Camera behavior toggle state
    private var isCameraBehaviorEnabled = true
    
    // Navigation state management
    private var isNavigationStarted = false
    
    // Route deviation handling
    private var isReturningToRoute = false
    private var deviationCounter = 0
    private val DEVIATION_THRESHOLD_METERS = 50
    private val MIN_DEVIATION_EVENTS = 3

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()


        // Initialize database manager
        databaseManager = DatabaseManager.getInstance(this)

        // Get trip ID and map visibility from intent
        val tripId = intent.getIntExtra(EXTRA_TRIP_ID, -1)
        showMap = intent.getBooleanExtra(EXTRA_SHOW_MAP, false)
        isSimulated = intent.getBooleanExtra(EXTRA_IS_SIMULATED, true)
        
        // Get network status from intent extras
        isNetworkConnected = intent.getBooleanExtra(EXTRA_NETWORK_CONNECTED, false)
        currentConnectionType = intent.getStringExtra(EXTRA_CONNECTION_TYPE) ?: "UNKNOWN"
        isConnectionMetered = intent.getBooleanExtra(EXTRA_IS_METERED, true)
        
        Log.d(TAG, "=== NETWORK STATUS FROM MAINACTIVITY ===")
        Log.d(TAG, "Connected: $isNetworkConnected")
        Log.d(TAG, "Type: $currentConnectionType")
        Log.d(TAG, "Metered: $isConnectionMetered")
        Log.d(TAG, "=====================================")

        if (tripId == -1) {
            Log.e(TAG, "No trip ID provided. Cannot start navigation.")
            finish()
            return
        }

        // Fetch trip from database
        lifecycleScope.launch {
            tripResponse = databaseManager.getTripById(tripId)
            if (tripResponse == null) {
                Log.e(TAG, "Trip with ID $tripId not found in database. Cannot start navigation.")
                finish()
                return@launch
            }

            // Get MQTT service instance
            mqttService = MqttService.getInstance()
            
            // Initialize trip progress tracker with MQTT service
            tripProgressTracker = TripProgressTracker(tripId, databaseManager, lifecycleScope, mqttService)

            logTripInfo()
            initializeNetworkMonitoring()
            initializeHERESDK()
            setupUI(savedInstanceState)

            ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
                val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
                v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
                insets
            }

            initializeComponents()
            
            // Initialize NFC reader after trip data is loaded (for headless mode)
            if (!showMap) {
                initializeNFCReader()
                Log.d(TAG, "NFC reader initialized after trip data loaded")
            }
        }
    }

    private fun logTripInfo() {
        tripResponse?.let { trip ->
            Log.d(TAG, "=== TRIP INFORMATION ===")
            Log.d(TAG, "Trip ID: ${trip.id}")
            Log.d(TAG, "Vehicle: ${trip.vehicle.license_plate}")
            Log.d(TAG, "Driver: ${trip.vehicle.driver?.name ?: "No driver assigned"}")
            Log.d(TAG, "Status: ${trip.status}")
            Log.d(TAG, "Seats: ${trip.seats}")
            Log.d(TAG, "Origin: ${trip.route.origin.google_place_name}")
            Log.d(TAG, "Destination: ${trip.route.destination.google_place_name}")
            Log.d(TAG, "Waypoints: ${trip.waypoints.size}")
            Log.d(TAG, "Custom waypoints: ${trip.has_custom_waypoints}")
            Log.d(TAG, "Connection mode: ${trip.connection_mode}")
            Log.d(TAG, "Network Status: Connected=$isNetworkConnected, Type=$currentConnectionType, Metered=$isConnectionMetered")
            trip.waypoints.forEachIndexed { index, waypoint ->
                Log.d(TAG, "  Waypoint ${index + 1}: ${waypoint.location.google_place_name} (Order: ${waypoint.order})")
            }
            Log.d(TAG, "=======================")
        }
    }

    private fun initializeNetworkMonitoring() {
        Log.d(TAG, "=== INITIALIZING NETWORK MONITORING ===")
        Log.d(TAG, "Using network status from MainActivity:")
        Log.d(TAG, "  Connected: $isNetworkConnected")
        Log.d(TAG, "  Type: $currentConnectionType")
        Log.d(TAG, "  Metered: $isConnectionMetered")

        // Use the received network status instead of re-scanning
        recommendRoutingStrategy(isNetworkConnected, isConnectionMetered)

        // Set up network monitoring for future changes only
        networkMonitor = NetworkMonitor(this) { connected, type, metered ->
            Log.d(TAG, "=== NETWORK STATE CHANGED ===")
            Log.d(TAG, "Previous: Connected=$isNetworkConnected, Type=$currentConnectionType, Metered=$isConnectionMetered")
            Log.d(TAG, "New: Connected=$connected, Type=$type, Metered=$metered")
            
            // Only handle changes, not initial setup
            if (connected != isNetworkConnected || type != currentConnectionType || metered != isConnectionMetered) {
                isNetworkConnected = connected
                currentConnectionType = type
                isConnectionMetered = metered
                handleNetworkStateChange(connected, type, metered)
            } else {
                Log.d(TAG, "No actual network change detected, ignoring")
            }
            Log.d(TAG, "==============================")
        }

        networkMonitor?.startMonitoring()
        Log.d(TAG, "Network monitoring started in Navigator for future changes")
    }

    private fun getNetworkBasedRoutingRecommendation(): Boolean {
        return when {
            !isNetworkConnected -> false
            currentConnectionType == "WIFI" && !isConnectionMetered -> true
            currentConnectionType.startsWith("CELLULAR") && isConnectionMetered -> false
            currentConnectionType.startsWith("CELLULAR") && !isConnectionMetered -> true
            else -> isNetworkConnected
        }
    }

    private fun recommendRoutingStrategy(internetAvailable: Boolean, isMetered: Boolean) {
        Log.d(TAG, "=== ROUTING STRATEGY RECOMMENDATION ===")

        val recommendation = when {
            !internetAvailable -> {
                "OFFLINE ROUTING ONLY - No internet connection detected"
            }
            isMetered -> {
                "HYBRID ROUTING RECOMMENDED - Connection is metered, prefer offline with dynamic fallback"
            }
            else -> {
                "DYNAMIC ROUTING OPTIMAL - Fast unmetered connection available"
            }
        }

        Log.d(TAG, "Recommendation: $recommendation")
        Log.d(TAG, "======================================")
    }

    private fun handleNetworkStateChange(connected: Boolean, type: String, metered: Boolean) {
        Log.d(TAG, "=== HANDLING NETWORK CHANGE ===")

        offlineSwitchRunnable?.let {
            handler.removeCallbacks(it)
            Log.d(TAG, "Cancelled pending offline switch task")
        }
        offlineSwitchRunnable = null

        when {
            !connected -> {
                Log.w(TAG, "Lost network connection - switching to offline mode")
                if (useDynamicRouting) {
                    Log.d(TAG, "Auto-switching from dynamic to offline routing")

                    offlineSwitchRunnable = Runnable {
                        if (!isNetworkConnected) {
                            toggleRoutingMode(false)
                        }
                        offlineSwitchRunnable = null
                    }

                    handler.postDelayed(offlineSwitchRunnable!!, 120000)
                    Log.d(TAG, "Scheduled offline switch in 2 minutes")
                }
                dynamicRoutingEngine?.stop()
            }

            connected && type == "CELLULAR" && metered -> {
                Log.w(TAG, "On metered cellular connection - using offline routing to save data")
                if (useDynamicRouting) {
                    Log.d(TAG, "Switching to offline routing to conserve data")
                    toggleRoutingMode(false)
                }
            }

            connected && type == "WIFI" && !metered -> {
                Log.d(TAG, "Fast WiFi connection available - dynamic routing optimal")
                if (!useDynamicRouting && currentRoute != null) {
                    Log.d(TAG, "Switching to dynamic routing for better traffic awareness")
                    toggleRoutingMode(true)
                }
            }

            connected && type.startsWith("CELLULAR") && !metered -> {
                Log.d(TAG, "Unlimited cellular connection - dynamic routing available")
                if (!useDynamicRouting && currentRoute != null) {
                    toggleRoutingMode(true)
                }
            }
        }

        Log.d(TAG, "==============================")
    }

    private fun initializeHERESDK() {
        val accessKeyID = BuildConfig.HERE_ACCESS_KEY_ID
        val accessKeySecret = BuildConfig.HERE_ACCESS_KEY_SECRET
        val authenticationMode = AuthenticationMode.withKeySecret(accessKeyID, accessKeySecret)
        val options = SDKOptions(authenticationMode)
        try {
            SDKNativeEngine.makeSharedInstance(this, options)
        } catch (e: InstantiationErrorException) {
            throw RuntimeException("Initialization of HERE SDK failed: " + e.error.name)
        }
    }

    private fun setupUI(savedInstanceState: Bundle?) {
        if (showMap) {
            setContentView(R.layout.activity_navigator)
            mapView = findViewById(R.id.mapView)
            mapView?.onCreate(savedInstanceState)
            
            // Initialize speed display UI elements
            initializeSpeedDisplay()
        } else {
            setContentView(R.layout.activity_navigator_headless)
            initializeHeadlessUI()
        }
    }

    private fun initializeSpeedDisplay() {
        try {
            speedValueTextView = findViewById(R.id.speedValue)
            speedUnitTextView = findViewById(R.id.speedUnit)
            speedAccuracyTextView = findViewById(R.id.speedAccuracy)
            speedDisplayContainer = findViewById(R.id.speedDisplayContainer)
            
            // Initialize with default values
            updateSpeedDisplay(0.0, 0.0)
            
            Log.d(TAG, "=== SPEED DISPLAY INITIALIZED ===")
            Log.d(TAG, "Speed display UI elements found and initialized")
            Log.d(TAG, "Speed display will be updated from location data")
            Log.d(TAG, "===============================")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize speed display UI: ${e.message}", e)
        }
    }

    private fun initializeHeadlessUI() {
        try {
            // Initialize UI elements
            currentLocationText = findViewById(R.id.currentLocationText)
            waypointsContainer = findViewById(R.id.waypointsContainer)
            
            // Update UI with trip information first
            updateWaypointsDisplay()
            
            // Initialize NFC reader only after trip data is loaded
            if (tripResponse != null) {
                initializeNFCReader()
                Log.d(TAG, "=== HEADLESS UI INITIALIZED ===")
                Log.d(TAG, "Headless mode UI elements initialized successfully")
                Log.d(TAG, "NFC reader ready for card scanning")
                Log.d(TAG, "Trip data loaded: ${tripResponse?.id}")
            } else {
                Log.w(TAG, "Trip data not yet loaded, NFC reader will be initialized later")
            }
            Log.d(TAG, "===============================")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize headless UI: ${e.message}", e)
        }
    }
    

    private fun initializeNFCReader() {
        try {
            nfcReaderHelper = NFCReaderHelper(
                context = this,
                onTagRead = { tag ->
                    handleNFCTagRead(tag)
                },
                onError = { error ->
                    Log.e(TAG, "NFC Error: $error")
                }
            )
            
            if (nfcReaderHelper?.isNfcSupported() == true) {
                if (nfcReaderHelper?.isNfcEnabled() == true) {
                    nfcReaderHelper?.enableNfcReader(this)
                    Log.d(TAG, "NFC reader enabled and ready")
                } else {
                    Log.w(TAG, "NFC is disabled. Please enable NFC in settings.")
                }
            } else {
                Log.w(TAG, "NFC not supported on this device")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize NFC reader: ${e.message}", e)
        }
    }

    private fun handleNFCTagRead(tag: android.nfc.Tag) {
        try {
            val nfcId = tag.id.joinToString("") { "%02x".format(it) }
            Log.d(TAG, "=== NFC TAG READ ===")
            Log.d(TAG, "NFC ID: $nfcId")
            Log.d(TAG, "Activity destroyed: $isDestroyed")
            Log.d(TAG, "Processing NFC: $isProcessingNFC")
            Log.d(TAG, "Showing booking confirmation: $isShowingBookingConfirmation")
            
            // Check if activity is destroyed before processing
            if (isDestroyed) {
                Log.w(TAG, "Activity is destroyed, ignoring NFC tag read")
                return
            }
            
            // Check if already processing an NFC tap
            if (isProcessingNFC) {
                Log.w(TAG, "Already processing NFC tap, queuing new tap")
                pendingNFCId = nfcId
                return
            }
            
            // Check if tripResponse is available
            if (tripResponse == null) {
                Log.e(TAG, "Trip response is null! Cannot show destinations.")
                return
            }
            
            // Set processing flag
            isProcessingNFC = true
            
            // Process on main thread
            handler.post {
                processNFCTap(nfcId)
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error handling NFC tag: ${e.message}", e)
            isProcessingNFC = false
        }
    }
    
    private fun processNFCTap(nfcId: String) {
        try {
            Log.d(TAG, "Processing NFC tap: $nfcId")
            
            // If showing confirmation, replace it immediately
            if (isShowingBookingConfirmation) {
                Log.d(TAG, "Replacing booking confirmation with new dialog")
                hideBookingConfirmationImmediate()
            }
            
            // Show destination selection dialog
            showWaypointSelectionDialog(nfcId)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error processing NFC tap: ${e.message}", e)
        } finally {
            isProcessingNFC = false
            
            // Process any pending NFC tap
            pendingNFCId?.let { pendingId ->
                Log.d(TAG, "Processing pending NFC tap: $pendingId")
                pendingNFCId = null
                handler.postDelayed({
                    processNFCTap(pendingId)
                }, 200) // Small delay to prevent rapid processing
            }
        }
    }


    private fun calculateTripPrice(): String {
        tripResponse?.let { trip ->
            // Trip price is from origin to final destination
            val destination = trip.route.destination
            val allWaypoints = trip.waypoints.sortedBy { it.order }
            
            // Find the last waypoint before destination
            val lastWaypoint = allWaypoints.lastOrNull()
            
            return if (lastWaypoint != null) {
                // Use the last waypoint's price as the trip price
                "${lastWaypoint.price.toInt()} RWF"
            } else {
                // If no waypoints, use a default trip price
                "500 RWF" // Default trip price
            }
        }
        return "Unknown"
    }

    private fun updateWaypointsDisplay() {
        tripResponse?.let { trip ->
            waypointsContainer?.removeAllViews()
            
            // Get current location for pricing calculation
            val currentLocation = getCurrentLocationName()
            currentLocationText?.text = "üìç $currentLocation"
            
            // Get available destinations (waypoints + final destination)
            val availableDestinations = getAvailableWaypoints()
            
            if (availableDestinations.isEmpty()) {
                val noWaypointsText = android.widget.TextView(this).apply {
                    text = "No available destinations"
                    textSize = 16f
                    setTextColor("#666666".toColorInt())
                    gravity = android.view.Gravity.CENTER
                }
                waypointsContainer?.addView(noWaypointsText)
            } else {
                availableDestinations.forEach { destination ->
                    val waypointView = createWaypointView(destination)
                    waypointsContainer?.addView(waypointView)
                }
            }
        }
    }


    private fun getCurrentLocationName(): String {
        tripResponse?.let { trip ->
            // Find the last passed waypoint to determine current location
            val passedWaypoints = trip.waypoints.filter { it.is_passed }.sortedBy { it.order }
            
            return when {
                passedWaypoints.isEmpty() -> getLocationDisplayName(trip.route.origin)
                passedWaypoints.size == trip.waypoints.size -> getLocationDisplayName(trip.route.destination)
                else -> getLocationDisplayName(passedWaypoints.last().location)
            }
        }
        return "Unknown"
    }

    private fun getLocationDisplayName(location: SavePlaceResponse): String {
        return location.custom_name?.takeIf { it.isNotBlank() } ?: location.google_place_name
    }

    private fun getAvailableWaypoints(): List<AvailableDestination> {
        tripResponse?.let { trip ->
            val allWaypoints = trip.waypoints
            val availableWaypoints = allWaypoints.filter { !it.is_passed }.sortedBy { it.order }
            val passedWaypoints = allWaypoints.filter { it.is_passed }
            
            Log.d(TAG, "=== DEBUGGING AVAILABLE DESTINATIONS ===")
            Log.d(TAG, "Total waypoints: ${allWaypoints.size}")
            Log.d(TAG, "Passed waypoints: ${passedWaypoints.size}")
            Log.d(TAG, "Available waypoints: ${availableWaypoints.size}")
            allWaypoints.forEach { wp ->
                val displayName = getLocationDisplayName(wp.location)
                Log.d(TAG, "  Waypoint: $displayName (passed: ${wp.is_passed}, order: ${wp.order})")
            }
            
            // Create a list that includes both waypoints and final destination
            val availableDestinations = mutableListOf<AvailableDestination>()
            
            // Add intermediate waypoints
            availableWaypoints.forEach { waypoint ->
                availableDestinations.add(
                    AvailableDestination(
                        id = waypoint.id,
                        location = waypoint.location,
                        price = waypoint.price,
                        order = waypoint.order,
                        isFinalDestination = false
                    )
                )
            }
            
            // Always add final destination (it should always be available for booking)
            val finalDestinationPrice = calculateFinalDestinationPrice()
            availableDestinations.add(
                AvailableDestination(
                    id = -1, // Special ID for final destination
                    location = trip.route.destination,
                    price = finalDestinationPrice,
                    order = Int.MAX_VALUE, // Always last
                    isFinalDestination = true
                )
            )
            
            Log.d(TAG, "Final available destinations: ${availableDestinations.size}")
            availableDestinations.forEach { dest ->
                val displayName = getLocationDisplayName(dest.location)
                Log.d(TAG, "  - $displayName (final: ${dest.isFinalDestination}, price: ${dest.price})")
            }
            Log.d(TAG, "=====================================")
            
            return availableDestinations
        }
        Log.w(TAG, "No trip response available for waypoints")
        return emptyList()
    }

    private fun calculateFinalDestinationPrice(): Double {
        tripResponse?.let { trip ->
            // Calculate trip price based on current location
            val currentLocation = getCurrentLocationName()
            val origin = getLocationDisplayName(trip.route.origin)
            val allWaypoints = trip.waypoints.sortedBy { it.order }
            val currentWaypointIndex = getCurrentWaypointIndex()
            
            return when {
                // If we're at origin, use the last waypoint's price as full trip price
                currentLocation == origin -> {
                    val lastWaypoint = allWaypoints.maxByOrNull { it.order }
                    lastWaypoint?.price ?: 1000.0
                }
                
                // If we're at an intermediate waypoint, calculate segment price to final destination
                currentWaypointIndex >= 0 -> {
                    val currentWaypoint = allWaypoints[currentWaypointIndex]
                    val lastWaypoint = allWaypoints.maxByOrNull { it.order }
                    val segmentPrice = (lastWaypoint?.price ?: 1000.0) - currentWaypoint.price
                    maxOf(0.0, segmentPrice)
                }
                
                // Fallback to default trip price
                else -> 1000.0
            }
        }
        return 1000.0
    }

    // Data class for available destinations (both waypoints and final destination)
    data class AvailableDestination(
        val id: Int,
        val location: SavePlaceResponse,
        val price: Double,
        val order: Int,
        val isFinalDestination: Boolean
    )

    private fun createWaypointView(destination: AvailableDestination): android.widget.LinearLayout {
        val inflater = layoutInflater
        val waypointView = inflater.inflate(R.layout.waypoint_item, waypointsContainer, false) as android.widget.LinearLayout
        
        val nameText = waypointView.findViewById<android.widget.TextView>(R.id.waypointName)
        val priceText = waypointView.findViewById<android.widget.TextView>(R.id.waypointPrice)
        val distanceText = waypointView.findViewById<android.widget.TextView>(R.id.waypointDistance)
        val statusText = waypointView.findViewById<android.widget.TextView>(R.id.waypointStatus)
        
        // Set waypoint name with flag icon
        val destinationDisplayName = getLocationDisplayName(destination.location)
        val flagIcon = if (destination.isFinalDestination) "üèÅ" else "üö©"
        nameText.text = "$flagIcon $destinationDisplayName"
        
        // Calculate and display price
        val price = calculateDestinationPrice(destination)
        priceText.text = price
        
        // Set distance information
        distanceText.text = if (destination.isFinalDestination) {
            "Final Destination"
        } else {
            "Distance: Unknown" // We don't have distance for final destination
        }
        
        // Set status
        statusText.text = if (destination.isFinalDestination) "Final" else "Available"
        
        // Remove click functionality - waypoints are only bookable via NFC card tap
        waypointView.isClickable = false
        waypointView.isFocusable = false
        
        return waypointView
    }

    private fun getRouteContext(currentIndex: Int, targetIndex: Int): String {
        if (currentIndex < 0 || targetIndex < 0) return ""
        
        val currentWaypoint = tripResponse?.waypoints?.sortedBy { it.order }?.getOrNull(currentIndex)
        val targetWaypoint = tripResponse?.waypoints?.sortedBy { it.order }?.getOrNull(targetIndex)
        
        return when {
            currentIndex == -1 -> {
                // At origin
                val origin = tripResponse?.route?.origin?.let { getLocationDisplayName(it) } ?: "Origin"
                val targetName = targetWaypoint?.location?.let { getLocationDisplayName(it) } ?: "Destination"
                "($origin ‚Üí $targetName)"
            }
            currentIndex < targetIndex -> {
                // Forward segment
                val currentName = currentWaypoint?.location?.let { getLocationDisplayName(it) } ?: "Current"
                val targetName = targetWaypoint?.location?.let { getLocationDisplayName(it) } ?: "Destination"
                "($currentName ‚Üí $targetName)"
            }
            else -> ""
        }
    }

    private fun calculateDestinationPrice(destination: AvailableDestination): String {
        tripResponse?.let { trip ->
            val currentLocation = getCurrentLocationName()
            val origin = getLocationDisplayName(trip.route.origin)
            
            // Get all waypoints sorted by order
            val allWaypoints = trip.waypoints.sortedBy { it.order }
            val currentWaypointIndex = getCurrentWaypointIndex()
            
            return when {
                // If we're at origin, show full price from origin to this destination
                currentLocation == origin -> {
                    "${destination.price.toInt()} RWF"
                }
                
                // If we're at an intermediate waypoint, calculate segment price
                currentWaypointIndex >= 0 && !destination.isFinalDestination -> {
                    val currentWaypoint = allWaypoints[currentWaypointIndex]
                    val segmentPrice = destination.price - currentWaypoint.price
                    "${maxOf(0.0, segmentPrice).toInt()} RWF"
                }
                
                // For final destination, use the trip price
                destination.isFinalDestination -> {
                    "${destination.price.toInt()} RWF"
                }
                
                // Fallback to destination's base price
                else -> "${destination.price.toInt()} RWF"
            }
        }
        
        return "${destination.price.toInt()} RWF"
    }

    private fun calculatePrice(waypoint: TripWaypoint): String {
        tripResponse?.let { trip ->
            val currentLocation = getCurrentLocationName()
            val origin = trip.route.origin.google_place_name
            val destination = trip.route.destination.google_place_name
            
            // Get all waypoints sorted by order
            val allWaypoints = trip.waypoints.sortedBy { it.order }
            val currentWaypointIndex = getCurrentWaypointIndex()
            
            return when {
                // If we're at origin, show full price from origin to this waypoint
                currentLocation == origin -> {
                    "${waypoint.price.toInt()} RWF"
                }
                
                // If we're at an intermediate waypoint, calculate segment price
                currentWaypointIndex >= 0 -> {
                    val segmentPrice = calculateSegmentPrice(currentWaypointIndex, waypoint, allWaypoints)
                    "${segmentPrice.toInt()} RWF"
                }
                
                // Fallback to waypoint's base price
                else -> "${waypoint.price.toInt()} RWF"
            }
        }
        
        return "${waypoint.price.toInt()} RWF"
    }

    private fun getCurrentWaypointIndex(): Int {
        tripResponse?.let { trip ->
            val currentLocation = getCurrentLocationName()
            val allWaypoints = trip.waypoints.sortedBy { it.order }
            
            // Find the last passed waypoint index
            val passedWaypoints = allWaypoints.filter { it.is_passed }
            return if (passedWaypoints.isEmpty()) {
                -1 // At origin
            } else {
                val lastPassedWaypoint = passedWaypoints.maxByOrNull { it.order }
                allWaypoints.indexOf(lastPassedWaypoint)
            }
        }
        return -1
    }

    private fun calculateSegmentPrice(currentIndex: Int, targetWaypoint: TripWaypoint, allWaypoints: List<TripWaypoint>): Double {
        // Calculate price from current waypoint to target waypoint
        // This is done by subtracting the current waypoint's price from the target waypoint's price
        
        val currentWaypoint = allWaypoints[currentIndex]
        val targetIndex = allWaypoints.indexOf(targetWaypoint)
        
        if (targetIndex <= currentIndex) {
            Log.w(TAG, "Invalid segment: target index $targetIndex <= current index $currentIndex")
            return 0.0 // Invalid segment
        }
        
        // Price from current to target = target price - current price
        val segmentPrice = targetWaypoint.price - currentWaypoint.price
        
        Log.d(TAG, "=== SEGMENT PRICE CALCULATION ===")
        Log.d(TAG, "Current waypoint: ${currentWaypoint.location.google_place_name} (${currentWaypoint.price} RWF)")
        Log.d(TAG, "Target waypoint: ${targetWaypoint.location.google_place_name} (${targetWaypoint.price} RWF)")
        Log.d(TAG, "Segment price: ${targetWaypoint.price} - ${currentWaypoint.price} = $segmentPrice RWF")
        Log.d(TAG, "=================================")
        
        // Ensure price is not negative
        return maxOf(0.0, segmentPrice)
    }

    private fun showWaypointSelectionDialog(nfcId: String) {
        Log.d(TAG, "=== SHOWING CUSTOM DESTINATION SELECTION DIALOG ===")
        Log.d(TAG, "NFC ID: $nfcId")
        Log.d(TAG, "Showing booking confirmation: $isShowingBookingConfirmation")
        
        val availableDestinations = getAvailableWaypoints()
        
        Log.d(TAG, "Available destinations count: ${availableDestinations.size}")
        availableDestinations.forEach { dest ->
            val displayName = getLocationDisplayName(dest.location)
            Log.d(TAG, "  - $displayName (final: ${dest.isFinalDestination})")
        }
        
        if (availableDestinations.isEmpty()) {
            Log.w(TAG, "No available destinations found!")
            android.app.AlertDialog.Builder(this)
                .setTitle("No Available Destinations")
                .setMessage("All waypoints have been passed. Trip is complete.")
                .setPositiveButton("OK", null)
                .show()
            return
        }
        
        val currentLocation = getCurrentLocationName()
        
        try {
            // Create and show custom dialog
            val dialog = DestinationSelectionDialog.newInstance(
                nfcId = nfcId,
                currentLocation = currentLocation,
                destinations = availableDestinations
            ) { selectedDestination ->
                Log.d(TAG, "User selected destination: ${getLocationDisplayName(selectedDestination.location)}")
                processBooking(nfcId, selectedDestination)
            }
            
            dialog.show(supportFragmentManager, "DestinationSelectionDialog")
            Log.d(TAG, "Custom dialog shown successfully")
            
        } catch (e: Exception) {
            Log.e(TAG, "Error showing custom dialog: ${e.message}", e)
            // Fallback: show a simple message
            android.app.AlertDialog.Builder(this)
                .setTitle("Error")
                .setMessage("Unable to show destinations. Please try again.")
                .setPositiveButton("OK", null)
                .show()
        }
    }


    private fun processBooking(nfcId: String, destination: AvailableDestination) {
        try {
            val destinationDisplayName = getLocationDisplayName(destination.location)
            val currentLocation = getCurrentLocationName()
            
            val booking = BookingRecord(
                nfcId = nfcId,
                waypointName = destinationDisplayName,
                timestamp = System.currentTimeMillis(),
                price = destination.price
            )
            
            recentBookings.add(0, booking) // Add to beginning of list
            if (recentBookings.size > 10) {
                recentBookings.removeAt(recentBookings.size - 1) // Keep only last 10
            }
            
            Log.d(TAG, "=== BOOKING PROCESSED ===")
            Log.d(TAG, "NFC ID: $nfcId")
            Log.d(TAG, "Destination: $destinationDisplayName")
            Log.d(TAG, "Price: ${destination.price} RWF")
            Log.d(TAG, "Is Final Destination: ${destination.isFinalDestination}")
            Log.d(TAG, "========================")
            
            // Show booking confirmation screen
            showBookingConfirmation(nfcId, currentLocation, destinationDisplayName, destination.price)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error processing booking: ${e.message}", e)
        }
    }
    
    private fun showBookingConfirmation(nfcId: String, fromLocation: String, toLocation: String, price: Double) {
        try {
            // Cancel any existing confirmation timeout
            confirmationRunnable?.let { handler.removeCallbacks(it) }
            
            // If already showing confirmation, replace it immediately
            if (isShowingBookingConfirmation) {
                hideBookingConfirmation()
            }
            
            isShowingBookingConfirmation = true
            
            // Hide the main content
            findViewById<android.widget.LinearLayout>(R.id.main)?.visibility = android.view.View.GONE
            
            // Create and show booking confirmation view
            val inflater = LayoutInflater.from(this)
            bookingConfirmationView = inflater.inflate(R.layout.booking_confirmation, null)
            
            // Set booking information
            val routeInfoText = bookingConfirmationView?.findViewById<android.widget.TextView>(R.id.routeInfoText)
            val priceInfoText = bookingConfirmationView?.findViewById<android.widget.TextView>(R.id.priceInfoText)
            val nfcCardText = bookingConfirmationView?.findViewById<android.widget.TextView>(R.id.nfcCardText)
            
            routeInfoText?.text = "From $fromLocation to $toLocation"
            priceInfoText?.text = "${price.toInt()} RWF"
            nfcCardText?.text = "NFC Card: $nfcId"
            
            // Add the confirmation view to the main layout
            val mainLayout = findViewById<android.widget.LinearLayout>(R.id.main)
            val parent = mainLayout?.parent as? android.view.ViewGroup
            parent?.addView(bookingConfirmationView)
            
            Log.d(TAG, "Booking confirmation shown: $fromLocation ‚Üí $toLocation for ${price.toInt()} RWF")
            
            // Auto-hide after 3 seconds
            confirmationRunnable = Runnable {
                hideBookingConfirmation()
            }
            handler.postDelayed(confirmationRunnable!!, 3000)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error showing booking confirmation: ${e.message}", e)
            isShowingBookingConfirmation = false
        }
    }
    
    private fun hideBookingConfirmationImmediate() {
        try {
            // Cancel any pending confirmation timeout
            confirmationRunnable?.let { handler.removeCallbacks(it) }
            confirmationRunnable = null
            
            isShowingBookingConfirmation = false
            
            // Remove the confirmation view immediately
            bookingConfirmationView?.let { view ->
                val parent = view.parent as? android.view.ViewGroup
                parent?.removeView(view)
            }
            bookingConfirmationView = null
            
            // Show the main content again immediately
            findViewById<android.widget.LinearLayout>(R.id.main)?.visibility = android.view.View.VISIBLE
            
            Log.d(TAG, "Booking confirmation hidden immediately")
            
        } catch (e: Exception) {
            Log.e(TAG, "Error hiding booking confirmation immediately: ${e.message}", e)
            isShowingBookingConfirmation = false
        }
    }
    
    private fun hideBookingConfirmation() {
        try {
            // Cancel any pending confirmation timeout
            confirmationRunnable?.let { handler.removeCallbacks(it) }
            confirmationRunnable = null
            
            isShowingBookingConfirmation = false
            
            // Remove the confirmation view
            bookingConfirmationView?.let { view ->
                val parent = view.parent as? android.view.ViewGroup
                parent?.removeView(view)
            }
            bookingConfirmationView = null
            
            // Show the main content again
            findViewById<android.widget.LinearLayout>(R.id.main)?.visibility = android.view.View.VISIBLE
            
            Log.d(TAG, "Booking confirmation hidden, ready for next booking")
            
        } catch (e: Exception) {
            Log.e(TAG, "Error hiding booking confirmation: ${e.message}", e)
            isShowingBookingConfirmation = false
        }
    }


    private fun updateSpeedFromLocation(location: Location) {
        val currentTime = System.currentTimeMillis()
        
        // Throttle updates to avoid UI spam
        if (currentTime - lastSpeedUpdateTime < SPEED_UPDATE_INTERVAL) {
            return
        }
        
        lastSpeedUpdateTime = currentTime
        
        val speed = location.speedInMetersPerSecond ?: 0.0
        val accuracy = location.speedAccuracyInMetersPerSecond ?: 0.0
        
        updateSpeedDisplay(speed, accuracy)
    }

    private fun updateSpeedDisplay(speedInMetersPerSecond: Double, accuracyInMetersPerSecond: Double) {
        try {
            // Convert m/s to km/h
            currentSpeedKmh = speedInMetersPerSecond * 3.6
            speedAccuracy = accuracyInMetersPerSecond * 3.6
            
            // Update UI on main thread
            handler.post {
                String.format("%.0f", currentSpeedKmh).also { speedValueTextView?.text = it }

                // Show accuracy if available and significant
                if (speedAccuracy > 0.1) {
                    "¬±${String.format("%.1f", speedAccuracy)} km/h".also { speedAccuracyTextView?.text = it }
                    speedAccuracyTextView?.visibility = android.view.View.VISIBLE
                } else {
                    speedAccuracyTextView?.visibility = android.view.View.GONE
                }
                
                // Change color based on speed (optional visual feedback)
                val speedColor = when {
                    currentSpeedKmh > 100 -> "#FF4444" // Red for high speed
                    currentSpeedKmh > 60 -> "#FFAA00"  // Orange for medium speed
                    else -> "#FFFFFF"                  // White for normal speed
                }
                speedValueTextView?.setTextColor(speedColor.toColorInt())
            }
            
            Log.d(TAG, "Speed updated: ${String.format("%.1f", currentSpeedKmh)} km/h (¬±${String.format("%.1f", speedAccuracy)} km/h)")
        } catch (e: Exception) {
            Log.e(TAG, "Error updating speed display: ${e.message}", e)
        }
    }

    private fun showSpeedDisplay(show: Boolean) {
        handler.post {
            speedDisplayContainer?.visibility = if (show) android.view.View.VISIBLE else android.view.View.GONE
        }
    }

    private fun resetSpeedDisplay() {
        handler.post {
            speedValueTextView?.text = "0"
            speedAccuracyTextView?.visibility = android.view.View.GONE
            speedValueTextView?.setTextColor("#FFFFFF".toColorInt())
        }
        currentSpeedKmh = 0.0
        speedAccuracy = 0.0
    }

    /**
     * Get current speed in km/h
     */
    fun getCurrentSpeedKmh(): Double {
        return currentSpeedKmh
    }

    /**
     * Get current speed accuracy in km/h
     */
    fun getCurrentSpeedAccuracyKmh(): Double {
        return speedAccuracy
    }

    /**
     * Get current speed in m/s
     */
    fun getCurrentSpeedMs(): Double {
        return currentSpeedKmh / 3.6
    }

    private fun initializeComponents() {
        initializeRoutingEngine()
        initializeLocationEngine()
        initializeMapDownloader()
    }

    private fun initializeLocationEngine() {
        try {
            locationEngine = LocationEngine()
            Log.d(TAG, "LocationEngine initialized successfully")
        } catch (e: InstantiationErrorException) {
            Log.e(TAG, "Initialization of LocationEngine failed: ${e.error.name}")
            // Continue without GPS if initialization fails
        }
    }
    private fun initializeRoutingEngine() {
        try {
            onlineRoutingEngine = RoutingEngine()
            offlineRoutingEngine = OfflineRoutingEngine()
            createDynamicRoutingEngine()
            Log.d(TAG, "All routing engines initialized successfully")
        } catch (e: InstantiationErrorException) {
            throw RuntimeException("Initialization of routing engines failed: " + e.error.name)
        }
    }

    private fun createDynamicRoutingEngine() {
        val dynamicRoutingOptions = DynamicRoutingEngineOptions().apply {
            minTimeDifference = Duration.ofSeconds(30)
            minTimeDifferencePercentage = 0.1
            pollInterval = Duration.ofMinutes(10)
        }

        try {
            dynamicRoutingEngine = DynamicRoutingEngine(dynamicRoutingOptions)
            Log.d(TAG, "DynamicRoutingEngine initialized successfully")
        } catch (e: InstantiationErrorException) {
            throw RuntimeException("Initialization of DynamicRoutingEngine failed: " + e.error.name)
        }
    }

    fun toggleRoutingMode(useDynamic: Boolean) {
        val previousMode = useDynamicRouting
        useDynamicRouting = useDynamic

        Log.d(TAG, "=== ROUTING MODE CHANGE ===")
        Log.d(TAG, "Previous Mode: ${if (previousMode) "Dynamic" else "Offline"}")
        Log.d(TAG, "New Mode: ${if (useDynamic) "Dynamic" else "Offline"}")
        Log.d(
            TAG,
            "Network Status: Connected=$isNetworkConnected, Type=$currentConnectionType, Metered=$isConnectionMetered"
        )
        Log.d(
            TAG,
            "Network Recommendation: ${if (getNetworkBasedRoutingRecommendation()) "Dynamic" else "Offline"}"
        )

        if (useDynamic && !isNetworkConnected) {
            Log.w(TAG, "WARNING: Dynamic routing requested but no network connection available!")
        }

        if (useDynamic && isConnectionMetered) {
            Log.w(TAG, "WARNING: Dynamic routing on metered connection - may incur data charges")
        }

        Log.d(TAG, "==========================")

        currentRoute?.let { route ->
            if (visualNavigator?.route != null || navigator?.route != null) {
                Log.d(TAG, "Restarting navigation with new routing engine")
                restartNavigationWithNewEngine(route)
            }
        }
    }

    private fun restartNavigationWithNewEngine(route: Route) {
        Log.d(TAG, "Restarting navigation with new routing engine")

        dynamicRoutingEngine?.stop()
        stopCurrentNavigation()

        handler.postDelayed({
            startGuidance(route)
        }, 100)
    }

    private fun stopCurrentNavigation() {
        Log.d(TAG, "Stopping current navigation instances")

        visualNavigator?.let { nav ->
            nav.stopRendering()
            nav.routeProgressListener = null
            nav.destinationReachedListener = null
            nav.speedLimitListener = null
            nav.milestoneStatusListener = null
            nav.safetyCameraWarningListener = null
            nav.speedWarningListener = null
            nav.route = null
            visualNavigator = null
            Log.d(TAG, "Visual navigator stopped and disposed")
        }

        navigator?.let { nav ->
            nav.routeProgressListener = null
            nav.route = null
            navigator = null
            Log.d(TAG, "Headless navigator stopped and disposed")
        }

        locationEngine?.let { engine ->
            try {
                engine.stop()
                Log.d(TAG, "Real location engine stopped")
            } catch (e: Exception) {
                Log.e(TAG, "Error stopping location engine: ${e.message}")
            }
        }

        locationSimulator?.let { simulator ->
            simulator.stop()
            simulator.listener = null
            locationSimulator = null
            Log.d(TAG, "Location simulator stopped")
        }
    }

    private fun initializeMapDownloader() {
        val sdkNativeEngine = SDKNativeEngine.getSharedInstance()
            ?: throw RuntimeException("SDKNativeEngine not initialized.")

        val storagePath = sdkNativeEngine.options.cachePath
        val persistentMapStoragePath = sdkNativeEngine.options.persistentMapStoragePath
        Log.d(TAG, "Cache storage path: $storagePath")
        Log.d(TAG, "Persistent map storage path: $persistentMapStoragePath")

        MapDownloader.fromEngineAsync(
            sdkNativeEngine
        ) { mapDownloader ->
            this@Navigator.mapDownloader = mapDownloader
            Log.d(TAG, "MapDownloader initialized successfully")

            checkExistingMapData()

            if (!isMapDataReady) {
                downloadRegionsList()
            }
        }
    }

    private fun checkExistingMapData() {
        mapDownloader?.let { downloader ->
            try {
                val installedRegions = downloader.installedRegions
                Log.d(TAG, "=== INSTALLED REGIONS CHECK ===")
                Log.d(
                    TAG,
                    "Total installed regions: ${installedRegions.size} ${installedRegions.fastForEach { it.regionId }}"
                )

                var rwandaFound = false
                for (region in installedRegions) {
                    val sizeInMB = region.sizeOnDiskInBytes / (1024 * 1024)
                    Log.d(
                        TAG,
                        "Installed region: ${region.regionId.id}, Size: ${sizeInMB}MB, Status: ${region.status}"
                    )

                    if (region.regionId.id.toString().contains("25726922", ignoreCase = true) ||
                        region.regionId.id.toString().contains("25726922", ignoreCase = true)
                    ) {
                        rwandaFound = true
                        Log.d(TAG, "Found existing Rwanda map data!")
                    }
                }

                if (rwandaFound) {
                    Log.d(TAG, "Rwanda map data already available")
                    isMapDataReady = true
                    proceedWithNavigation()
                } else {
                    Log.d(TAG, "No Rwanda map data found, will download after region list")
                }

                Log.d(TAG, "==============================")
            } catch (e: MapLoaderException) {
                Log.e(TAG, "Error checking installed regions: ${e.error}")
            }
        }
    }

    private fun downloadRegionsList() {
        mapDownloader?.let { downloader ->
            Log.d(TAG, "Downloading list of available regions...")

            downloader.getDownloadableRegions(
                LanguageCode.EN_US,
                object : DownloadableRegionsCallback {
                    override fun onCompleted(
                        mapLoaderError: MapLoaderError?,
                        regions: MutableList<Region>?
                    ) {
                        if (mapLoaderError != null) {
                            Log.e(TAG, "Error downloading regions list: $mapLoaderError")
                            return
                        }

                        if (regions != null) {
                            downloadableRegions = regions
                            Log.d(TAG, "=== DOWNLOADABLE REGIONS ===")
                            Log.d(TAG, "Found ${regions.size} top-level regions")

                            logAllRegions(regions)

                            val rwandaRegion = findRwandaRegion(regions)
                            if (rwandaRegion != null) {
                                Log.d(TAG, "Found Rwanda region!")
                                if (!isMapDataReady) {
                                    downloadRwandaMap(rwandaRegion)
                                } else {
                                    proceedWithNavigation()
                                }
                            } else {
                                Log.e(TAG, "Rwanda region not found in available regions!")
                                proceedWithNavigation()
                            }
                            Log.d(TAG, "============================")
                        }
                    }
                })
        }
    }

    private fun logAllRegions(regions: List<Region>) {
        for (region in regions) {
            val sizeInMB = region.sizeOnDiskInBytes / (1024 * 1024)
            Log.d(TAG, "Continent: ${region.name}, Size: ${sizeInMB}MB")

            region.childRegions?.let { childRegions ->
                Log.d(TAG, "  Countries in ${region.name}:")
                for (childRegion in childRegions) {
                    val childSizeInMB = childRegion.sizeOnDiskInBytes / (1024 * 1024)
                    Log.d(
                        TAG,
                        "    - ${childRegion.name} (ID: ${childRegion.regionId.id}, Size: ${childSizeInMB}MB)"
                    )

                    childRegion.childRegions?.let { subRegions ->
                        for (subRegion in subRegions.take(5)) {
                            val subSizeInMB = subRegion.sizeOnDiskInBytes / (1024 * 1024)
                            Log.d(TAG, "        ‚îî ${subRegion.name} (${subSizeInMB}MB)")
                        }
                        if (subRegions.size > 5) {
                            Log.d(TAG, "        ‚îî ... and ${subRegions.size - 5} more sub-regions")
                        }
                    }
                }
            }
        }
    }

    private fun findRwandaRegion(regions: List<Region>): Region? {
        val rwandaNames = listOf(
            "Rwanda", "RWANDA", "rwanda",
            "Republic of Rwanda", "R√©publique du Rwanda",
            "U Rwanda"
        )

        for (region in regions) {
            for (name in rwandaNames) {
                if (region.name.equals(name, ignoreCase = true) ||
                    region.name.contains(name, ignoreCase = true)
                ) {
                    Log.d(TAG, "Found Rwanda at top level: ${region.name}")
                    return region
                }
            }

            region.childRegions?.let { childRegions ->
                for (childRegion in childRegions) {
                    for (name in rwandaNames) {
                        if (childRegion.name.equals(name, ignoreCase = true) ||
                            childRegion.name.contains(name, ignoreCase = true)
                        ) {
                            Log.d(TAG, "Found Rwanda in ${region.name}: ${childRegion.name}")
                            return childRegion
                        }
                    }

                    childRegion.childRegions?.let { subRegions ->
                        for (subRegion in subRegions) {
                            for (name in rwandaNames) {
                                if (subRegion.name.equals(name, ignoreCase = true) ||
                                    subRegion.name.contains(name, ignoreCase = true)
                                ) {
                                    Log.d(
                                        TAG,
                                        "Found Rwanda in ${childRegion.name}: ${subRegion.name}"
                                    )
                                    return subRegion
                                }
                            }
                        }
                    }
                }
            }
        }

        return null
    }

    private fun removeOriginMarker() {
        mapView?.let { mapView ->
            if (waypointMarkers.isNotEmpty()) {
                val originMarker = waypointMarkers[0]
                mapView.mapScene.removeMapMarker(originMarker)
                waypointMarkers.removeAt(0)
                Log.d(TAG, "Removed origin marker - navigation started")
            }
        }
    }

    private fun downloadRwandaMap(rwandaRegion: Region) {
        mapDownloader?.let { downloader ->
            val sizeInMB = rwandaRegion.sizeOnDiskInBytes / (1024 * 1024)
            Log.d(TAG, "=== DOWNLOADING RWANDA MAP ===")
            Log.d(TAG, "Region: ${rwandaRegion.name}")
            Log.d(TAG, "Size: ${sizeInMB}MB")
            Log.d(TAG, "ID: ${rwandaRegion.regionId.id}")
            Log.d(TAG, "==============================")

            val regionIds = listOf(rwandaRegion.regionId)
            val downloadTask =
                downloader.downloadRegions(regionIds, object : DownloadRegionsStatusListener {
                    override fun onDownloadRegionsComplete(
                        mapLoaderError: MapLoaderError?,
                        regionIds: List<RegionId>?
                    ) {
                        if (mapLoaderError != null) {
                            Log.e(TAG, "Rwanda map download failed: $mapLoaderError")
                            proceedWithNavigation()
                            return
                        }

                        if (regionIds != null) {
                            Log.d(TAG, "=== DOWNLOAD COMPLETED ===")
                            Log.d(TAG, "Successfully downloaded Rwanda map!")
                            Log.d(TAG, "Downloaded regions: ${regionIds.map { it.id }}")
                            Log.d(TAG, "==========================")

                            isMapDataReady = true
                            proceedWithNavigation()
                        }
                    }

                    override fun onProgress(regionId: RegionId, percentage: Int) {
                        Log.d(
                            TAG,
                            "Downloading Rwanda map: ${percentage}% (Region: ${regionId.id})"
                        )
                    }

                    override fun onPause(mapLoaderError: MapLoaderError?) {
                        if (mapLoaderError == null) {
                            Log.d(TAG, "Rwanda map download paused by user")
                        } else {
                            Log.e(TAG, "Rwanda map download paused due to error: $mapLoaderError")
                        }
                    }

                    override fun onResume() {
                        Log.d(TAG, "Rwanda map download resumed")
                    }
                })

            mapDownloaderTasks.add(downloadTask)
        }
    }

    private fun proceedWithNavigation() {
        Log.d(TAG, "Proceeding with navigation setup...")

        if (!isSimulated) {
            // Start location engine first, then wait for location
            startLocationEngineAndWaitForLocation()
        } else {
            // For simulated mode, proceed immediately
            isNavigationStarted = true
            calculateRouteAndStartNavigation()
        }
    }

    private fun getCurrentLocation(): Location? {
        return locationEngine?.lastKnownLocation
    }

    private fun startLocationEngineAndWaitForLocation() {
        locationEngine?.let { engine ->
            Log.d(TAG, "Starting location engine for real-time navigation...")
            
            val locationStatusListener: LocationStatusListener = object : LocationStatusListener {
                override fun onStatusChanged(locationEngineStatus: LocationEngineStatus) {
                    Log.d(TAG, "Location engine status: ${locationEngineStatus.name}")
                    when (locationEngineStatus) {
                        LocationEngineStatus.ENGINE_STARTED -> {
                            Log.d(TAG, "Location engine started successfully")
                        }
                        LocationEngineStatus.ENGINE_STOPPED -> {
                            Log.w(TAG, "Location engine stopped")
                        }
                        else -> {
                            Log.d(TAG, "Location engine status: ${locationEngineStatus.name}")
                        }
                    }
                }

                override fun onFeaturesNotAvailable(features: List<LocationFeature>) {
                    for (feature in features) {
                        Log.w(TAG, "Location feature not available: ${feature.name}")
                    }
                }
            }

            val locationListener = LocationListener { location ->
                Log.d(TAG, "Received location: ${location.coordinates.latitude}, ${location.coordinates.longitude}, speed: ${location.speedInMetersPerSecond}")
                currentUserLocation = location
                
                // Update speed display if showing map
                if (showMap) {
                    updateSpeedFromLocation(location)
                }
                
                // Start navigation once we have a location (only once)
                if (currentUserLocation != null && !isNavigationStarted) {
                    Log.d(TAG, "Location acquired, starting navigation...")
                    isNavigationStarted = true
                    calculateRouteAndStartNavigation()
                }
            }

            try {
                engine.addLocationListener(locationListener)
                engine.addLocationStatusListener(locationStatusListener)
                engine.confirmHEREPrivacyNoticeInclusion()
                engine.start(LocationAccuracy.NAVIGATION)
                
                // Set a timeout to fallback to simulation if no location is received
                handler.postDelayed({
                    if (currentUserLocation == null && !isNavigationStarted) {
                        Log.w(TAG, "No location received within timeout, falling back to simulated navigation")
                        isSimulated = true
                        isNavigationStarted = true
                        calculateRouteAndStartNavigation()
                    }
                }, 10000) // 10 second timeout
                
            } catch (e: Exception) {
                Log.e(TAG, "Failed to start location engine: ${e.message}", e)
                Log.w(TAG, "Falling back to simulated navigation due to GPS failure")
                isSimulated = true
                isNavigationStarted = true
                calculateRouteAndStartNavigation()
            }
        } ?: run {
            Log.w(TAG, "Location engine not available, falling back to simulated navigation")
            isSimulated = true
            isNavigationStarted = true
            calculateRouteAndStartNavigation()
        }
    }


    private fun calculateRouteAndStartNavigation() {
        tripResponse?.let { trip ->
            var origin: Waypoint? = null
            if (currentUserLocation == null && !isSimulated) {
                Log.w(TAG, "No current user location available, switching to simulated navigation")
                isSimulated = true
            } else {
                currentUserLocation?.let {
                    origin = Waypoint(it.coordinates)
                    origin.headingInDegrees = it.bearingInDegrees
                    mapView?.camera?.lookAt(it.coordinates)

                }
            }
            val waypoints = createWaypointsFromTrip(trip, origin)

            val carOptions = CarOptions().apply {
                routeOptions.optimizeWaypointsOrder = false // Keep original order from trip
                routeOptions.enableTolls = true
                routeOptions.alternatives = 1
                routeOptions.enableRouteHandle = true // Required for rerouting functionality
            }

            val routingEngine = getSelectedRoutingEngine()

            Log.d(
                TAG,
                "Calculating route using: ${if (useDynamicRouting) "Online RoutingEngine" else "Offline RoutingEngine"}"
            )
            Log.d(TAG, "Trip ID: ${trip.id}")
            Log.d(TAG, "Waypoints: ${waypoints.size}")

            routingEngine.calculateRoute(waypoints, carOptions) { routingError, routes ->
                if (routingError == null && routes != null && routes.isNotEmpty()) {
                    val route = routes[0]
                    currentRoute = route
                    
                    // Set route in progress tracker
                    tripProgressTracker?.setCurrentRoute(route)
                    
                    Log.d(
                        TAG,
                        "Route calculated successfully using ${if (useDynamicRouting) "online" else "offline"} engine"
                    )
                    logRouteInfo(route)

                    if (showMap) {
                        showRouteOnMap(route)
                        addWaypointMarkersToMap(waypoints)
                    }

                    startGuidance(route)
                } else {
                    Log.e(TAG, "Route calculation failed: ${routingError?.name}")
                    if (useDynamicRouting && routingError != null) {
                        Log.d(TAG, "Online routing failed, trying offline routing as fallback")
                        fallbackToOfflineRouting(waypoints, carOptions)
                    }
                }
            }
        } ?: run {
            Log.e(TAG, "No trip data available for route calculation")
        }
    }

    private fun createWaypointsFromTrip(trip: TripResponse, origin: Waypoint? = null): List<Waypoint> {
        val waypoints = mutableListOf<Waypoint>()
        if(origin != null) {
            waypoints.add(origin)
        }

        // Add origin
        val origin = Waypoint(
            GeoCoordinates(
                trip.route.origin.latitude,
                trip.route.origin.longitude
            )
        ).apply {
            type = WaypointType.STOPOVER
        }
        waypoints.add(origin)

        // Add intermediate waypoints sorted by order
        val sortedWaypoints = trip.waypoints.sortedBy { it.order }
        sortedWaypoints.forEach { tripWaypoint ->
            val waypoint = Waypoint(
                GeoCoordinates(
                    tripWaypoint.location.latitude,
                    tripWaypoint.location.longitude
                )
            ).apply {
                type = WaypointType.STOPOVER
            }
            waypoints.add(waypoint)
        }

        // Add destination
        val destination = Waypoint(
            GeoCoordinates(
                trip.route.destination.latitude,
                trip.route.destination.longitude
            )
        ).apply {
            type = WaypointType.STOPOVER
        }
        waypoints.add(destination)

        Log.d(TAG, "Created ${waypoints.size} waypoints from trip data:")
        Log.d(TAG, "  Origin: ${trip.route.origin.google_place_name}")
        sortedWaypoints.forEachIndexed { index, waypoint ->
            Log.d(TAG, "  Waypoint ${index + 1}: ${waypoint.location.google_place_name}")
        }
        Log.d(TAG, "  Destination: ${trip.route.destination.google_place_name}")

        return waypoints
    }

    private fun addWaypointMarkersToMap(waypoints: List<Waypoint>) {
        mapView?.let { mapView ->
            waypointMarkers.forEach { mapView.mapScene.removeMapMarker(it) }
            waypointMarkers.clear()

            waypoints.forEachIndexed { index, waypoint ->
                val marker = when (index) {
                    0 -> createMarker(waypoint.coordinates)
                    waypoints.size - 1 -> createMarker(waypoint.coordinates)
                    else -> createMarker(waypoint.coordinates)
                }

                mapView.mapScene.addMapMarker(marker)
                waypointMarkers.add(marker)
            }

            Log.d(TAG, "Added ${waypointMarkers.size} waypoint markers to map")
        }
    }

    private fun createMarker(coordinates: GeoCoordinates): MapMarker {
        val mapImage = createMapImageFromVectorDrawable(R.drawable.ic_marker, 32)
        val anchor = Anchor2D(0.5, 1.0)
        return MapMarker(coordinates, mapImage, anchor)
    }

    private fun createMapImageFromVectorDrawable(drawableRes: Int, sizeInDp: Int = 31): MapImage {
        markerImageCache[drawableRes]?.let { return it }

        try {
            val vectorDrawable = ContextCompat.getDrawable(this, drawableRes) as? VectorDrawable
                ?: throw IllegalArgumentException("Resource $drawableRes is not a VectorDrawable")

            val density = this.resources.displayMetrics.density
            val sizeInPixels = (sizeInDp * density).toInt()

            val bitmap = createBitmap(sizeInPixels, sizeInPixels)

            val canvas = Canvas(bitmap)
            vectorDrawable.setBounds(0, 0, sizeInPixels, sizeInPixels)
            vectorDrawable.draw(canvas)

            val stream = ByteArrayOutputStream()
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            val byteArray = stream.toByteArray()

            val mapImage = MapImage(byteArray, ImageFormat.PNG)

            markerImageCache[drawableRes] = mapImage

            Log.d(
                TAG,
                "Created MapImage from vector drawable $drawableRes with size ${sizeInPixels}px (${sizeInDp}dp)"
            )
            return mapImage

        } catch (e: Exception) {
            Log.e(TAG, "Failed to create MapImage from vector drawable $drawableRes: ${e.message}")
            return MapImageFactory.fromResource(
                this.resources,
                android.R.drawable.ic_menu_mylocation
            )
        }
    }

    private fun showRouteOnMap(route: Route) {
        mapView?.let { mapView ->
            routeMapPolyline?.let {
                mapView.mapScene.removeMapPolyline(it)
            }

            val routeGeoPolyline = route.geometry
            val widthInPixels = 20f
            val routeColor = Color.valueOf(0f, 0.56f, 0.54f, 0.63f)
            routeMapPolyline = MapPolyline(
                routeGeoPolyline, MapPolyline.SolidRepresentation(
                    MapMeasureDependentRenderSize(RenderSize.Unit.PIXELS, widthInPixels.toDouble()),
                    routeColor,
                    LineCap.ROUND
                )
            )
            mapView.mapScene.addMapPolyline(routeMapPolyline!!)

            Log.d(TAG, "Route displayed on map with ${route.sections.size} sections")
        }
    }

    private fun getSelectedRoutingEngine(): RoutingInterface {
        return if (useDynamicRouting && isNetworkAvailable()) {
            onlineRoutingEngine!!
        } else {
            Log.d(TAG, "Using offline routing engine")
            offlineRoutingEngine!!
        }
    }

    private fun fallbackToOfflineRouting(waypoints: List<Waypoint>, carOptions: CarOptions) {
        offlineRoutingEngine?.calculateRoute(
            waypoints, carOptions
        ) { routingError, routes ->
            if (routingError == null && routes != null && routes.isNotEmpty()) {
                val route = routes[0]
                currentRoute = route
                
                // Set route in progress tracker
                tripProgressTracker?.setCurrentRoute(route)
                
                Log.d(TAG, "Route calculated successfully using offline engine (fallback)")
                logRouteInfo(route)
                startGuidance(route)
            } else {
                Log.e(
                    TAG,
                    "Both online and offline route calculation failed: ${routingError?.name}"
                )
            }
        }
    }

    private fun isNetworkAvailable(): Boolean {
        return useDynamicRouting
    }

    private fun logRouteInfo(route: Route) {
        val distanceInMeters = route.lengthInMeters
        val distanceInKm = distanceInMeters / 1000.0
        val durationInSeconds = route.duration.seconds
        val durationInMinutes = TimeUnit.SECONDS.toMinutes(durationInSeconds)
        val hours = durationInMinutes / 60
        val minutes = durationInMinutes % 60

        tripResponse?.let { trip ->
            Log.d(TAG, "=== ROUTE INFORMATION ===")
            Log.d(TAG, "Trip ID: ${trip.id}")
            Log.d(TAG, "Vehicle: ${trip.vehicle.license_plate}")
            Log.d(TAG, "Total Distance: ${String.format("%.2f", distanceInKm)} km")
            Log.d(TAG, "Estimated Duration: ${hours}h ${minutes}m")
            Log.d(TAG, "Origin: ${trip.route.origin.google_place_name}")
            Log.d(TAG, "Destination: ${trip.route.destination.google_place_name}")
            Log.d(TAG, "Intermediate waypoints: ${trip.waypoints.size}")
            Log.d(TAG, "Navigation Mode: ${if (showMap) "Visual Navigator" else "Headless Navigator"}")
            Log.d(
                TAG,
                "Routing Mode: ${if (useDynamicRouting) "Dynamic (with live traffic)" else "Offline"}"
            )
            Log.d(
                TAG,
                "Map Data Status: ${if (isMapDataReady) "Offline Ready" else "Cache/Online Only"}"
            )
            Log.d(TAG, "========================")
        }
    }

    private fun startGuidance(route: Route) {
        removeOriginMarker()
        
        // Reset deviation state for new route
        resetDeviationState()
        
        // Update trip status to in_progress as soon as guidance starts
        updateTripStatusToInProgress { success ->
            if (success) {
                // Send trip start notification via MQTT only after status update is complete
                tripProgressTracker?.sendTripStartNotification()
            } else {
                Log.e(TAG, "Failed to update trip status, skipping MQTT notification")
            }
        }
        
        if (showMap && mapView != null) {
            startVisualNavigation(route)
        } else {
            startHeadlessNavigation(route)
        }

        if (useDynamicRouting) {
            startDynamicSearchForBetterRoutes(route)
        }
    }

    private fun startDynamicSearchForBetterRoutes(route: Route) {
        dynamicRoutingEngine?.let { engine ->
            try {
                Log.d(TAG, "Starting dynamic routing for better route search")
                engine.start(route, object : DynamicRoutingListener {
                    override fun onBetterRouteFound(
                        newRoute: Route,
                        etaDifferenceInSeconds: Int,
                        distanceDifferenceInMeters: Int
                    ) {
                        Log.d(TAG, "=== BETTER ROUTE FOUND ===")
                        Log.d(TAG, "ETA difference: ${etaDifferenceInSeconds}s")
                        Log.d(TAG, "Distance difference: ${distanceDifferenceInMeters}m")

                        if (etaDifferenceInSeconds < -60 || distanceDifferenceInMeters < -500) {
                            Log.d(TAG, "Accepting better route automatically")
                            updateToNewRoute(newRoute)
                        } else {
                            Log.d(
                                TAG,
                                "Better route found but improvement not significant enough for auto-switch"
                            )
                        }
                        Log.d(TAG, "========================")
                    }

                    override fun onRoutingError(routingError: RoutingError) {
                        Log.w(TAG, "Error in dynamic routing: ${routingError.name}")
                    }
                })
            } catch (e: DynamicRoutingEngine.StartException) {
                Log.e(TAG, "Failed to start dynamic routing: ${e.message}")
            }
        }
    }

    private fun updateToNewRoute(newRoute: Route) {
        currentRoute = newRoute

        // Update route in progress tracker
        tripProgressTracker?.setCurrentRoute(newRoute)

        visualNavigator?.route = newRoute
        navigator?.route = newRoute

        Log.d(TAG, "Updated to better route")
        logRouteInfo(newRoute)
    }

    private fun startVisualNavigation(route: Route) {
        try {
            visualNavigator = VisualNavigator()
        } catch (e: InstantiationErrorException) {
            throw RuntimeException("Initialization of VisualNavigator failed: " + e.error.name)
        }

        mapView?.mapScene?.loadScene(MapScheme.NORMAL_DAY) { mapError ->
            if (mapError == null) {
                visualNavigator?.let { nav ->
                    nav.startRendering(mapView!!)
                    nav.cameraBehavior = if (isCameraBehaviorEnabled) DynamicCameraBehavior() else null

                    setupNavigationListeners(nav)
                    setupRouteProgressListener(nav)

                    nav.destinationReachedListener = DestinationReachedListener {
                        Log.d(TAG, "Destination reached!")
                        nav.stopRendering()
                    }

                    nav.route = route
                    setupLocationSource(nav, route, isSimulator = isSimulated)
                    Log.d(TAG, "Visual navigation started")
                }
            } else {
                Log.e(TAG, "Map scene loading failed: ${mapError.name}")
            }
        }
    }

    private fun startHeadlessNavigation(route: Route) {
        try {
            navigator = Navigator()
        } catch (e: InstantiationErrorException) {
            throw RuntimeException("Initialization of Navigator failed: " + e.error.name)
        }

        navigator?.let { nav ->
            setupRouteProgressListener(nav)
            nav.route = route
            setupLocationSource(nav, route, isSimulated)
            Log.d(TAG, "Headless navigation started")
        }
    }

    private fun setupNavigationListeners(nav: VisualNavigator) {
        nav.speedLimitListener = SpeedLimitListener { speedLimit: SpeedLimit ->
            val currentSpeedLimit = getCurrentSpeedLimit(speedLimit)
            when (currentSpeedLimit) {
                null -> Log.d(TAG, "Speed limit data unavailable")
                0.0 -> Log.d(TAG, "No speed limit on this road")
                else -> Log.d(TAG, "Current speed limit: $currentSpeedLimit m/s")
            }
        }

        nav.milestoneStatusListener =
            MilestoneStatusListener { milestone: Milestone, milestoneStatus: MilestoneStatus ->
                when {
                    milestone.waypointIndex != null && milestoneStatus == MilestoneStatus.REACHED -> {
                        Log.d(TAG, "üéâ WAYPOINT REACHED!")
                        Log.d(TAG, "Waypoint index: ${milestone.waypointIndex}")
                        Log.d(TAG, "Original coordinates: ${milestone.originalCoordinates}")
                        Log.d(TAG, "Map-matched coordinates: ${milestone.mapMatchedCoordinates}")

                        updateWaypointMarker(milestone.waypointIndex!!, true)
                        updateTripWaypointStatus(milestone.waypointIndex!!, true)
                    }

                    milestone.waypointIndex != null && milestoneStatus == MilestoneStatus.MISSED -> {
                        Log.w(TAG, "‚ö†Ô∏è WAYPOINT MISSED!")
                        Log.w(TAG, "Waypoint index: ${milestone.waypointIndex}")
                        Log.w(TAG, "Original coordinates: ${milestone.originalCoordinates}")

                        handleMissedWaypoint(milestone)
                        updateWaypointMarker(milestone.waypointIndex!!, false)
                        updateTripWaypointStatus(milestone.waypointIndex!!, false)
                    }

                    milestone.waypointIndex == null && milestoneStatus == MilestoneStatus.REACHED -> {
                        Log.d(
                            TAG,
                            "üîÑ System waypoint reached at: ${milestone.mapMatchedCoordinates}"
                        )
                    }

                    milestone.waypointIndex == null && milestoneStatus == MilestoneStatus.MISSED -> {
                        Log.w(
                            TAG,
                            "‚ö†Ô∏è System waypoint missed at: ${milestone.mapMatchedCoordinates}"
                        )
                    }
                }
            }

        nav.safetyCameraWarningListener = SafetyCameraWarningListener { warning ->
            val distance = warning.distanceToCameraInMeters
            val speedLimit = warning.speedLimitInMetersPerSecond
            when (warning.distanceType) {
                DistanceType.AHEAD -> Log.d(
                    TAG,
                    "Safety camera ${warning.type.name} ahead: ${distance}m, limit: ${speedLimit}m/s"
                )

                DistanceType.PASSED -> Log.d(
                    TAG,
                    "Safety camera ${warning.type.name} passed: ${distance}m"
                )

                DistanceType.REACHED -> Log.d(TAG, "Safety camera ${warning.type.name} reached")
            }
        }

        nav.speedWarningListener = SpeedWarningListener { status ->
            when (status) {
                SpeedWarningStatus.SPEED_LIMIT_EXCEEDED -> {
                    Log.d(TAG, "Speed limit exceeded!")
                    val ringtoneUri =
                        RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)
                    val ringtone = RingtoneManager.getRingtone(this, ringtoneUri)
                    ringtone.play()
                }

                SpeedWarningStatus.SPEED_LIMIT_RESTORED -> {
                    Log.d(TAG, "Speed back within limits")
                }
            }
        }
    }

    private fun updateTripWaypointStatus(waypointIndex: Int, reached: Boolean) {
        tripResponse?.let { trip ->
            // Map waypoint index to trip waypoints (accounting for origin being index 0)
            if (waypointIndex > 0 && waypointIndex <= trip.waypoints.size) {
                val tripWaypointIndex = waypointIndex - 1 // Adjust for origin
                val sortedWaypoints = trip.waypoints.sortedBy { it.order }
                if (tripWaypointIndex < sortedWaypoints.size) {
                    val tripWaypoint = sortedWaypoints[tripWaypointIndex]

                    val waypointDisplayName = getLocationDisplayName(tripWaypoint.location)
                    Log.d(TAG, "Waypoint $waypointDisplayName ${if (reached) "reached" else "missed"}")

                    // Update local waypoint status
                    if (reached) {
                        updateWaypointAsPassed(tripWaypoint)
                    }

                    // Here you could update the waypoint status in your backend
                    // updateWaypointStatusOnServer(tripWaypoint.id, reached)
                }
            }
        }
    }

    private fun updateWaypointAsPassed(waypoint: TripWaypoint) {
        // Update the waypoint status in the local trip response
        tripResponse?.let { trip ->
            val updatedWaypoints = trip.waypoints.map { wp ->
                if (wp.id == waypoint.id) {
                    wp.copy(is_passed = true, is_next = false)
                } else {
                    wp
                }
            }
            
            // Update the next waypoint as the next one
            val nextWaypoint = updatedWaypoints
                .filter { !it.is_passed }
                .minByOrNull { it.order }
            
            val finalWaypoints = updatedWaypoints.map { wp ->
                if (nextWaypoint != null && wp.id == nextWaypoint.id) {
                    wp.copy(is_next = true)
                } else {
                    wp.copy(is_next = false)
                }
            }
            
            tripResponse = trip.copy(waypoints = finalWaypoints)
            
            // Update headless UI if in headless mode
            if (!showMap) {
                updateWaypointsDisplay()
            }
            
            val waypointDisplayName = getLocationDisplayName(waypoint.location)
            Log.d(TAG, "Waypoint $waypointDisplayName marked as passed")
        }
    }

    private fun updateWaypointMarker(waypointIndex: Int, reached: Boolean) {
        if (waypointIndex < waypointMarkers.size) {
            val marker = waypointMarkers[waypointIndex]
            Log.d(
                TAG,
                "Updated marker for waypoint $waypointIndex - ${if (reached) "reached" else "missed"}"
            )
        }
    }

    private fun handleMissedWaypoint(milestone: Milestone) {
        Log.w(TAG, "=== HANDLING MISSED WAYPOINT ===")
        Log.w(TAG, "Consider recalculating route to include missed waypoint")

        currentRoute?.let { route ->
            Log.w(TAG, "Current route has ${route.sections.size} sections")
            Log.w(TAG, "Continuing with current route despite missed waypoint")
        }
        Log.w(TAG, "===============================")
    }

    private fun getCurrentSpeedLimit(speedLimit: SpeedLimit): Double? {
        Log.d(
            TAG, "Speed limits - Regular: ${speedLimit.speedLimitInMetersPerSecond}, " +
                    "School: ${speedLimit.schoolZoneSpeedLimitInMetersPerSecond}, " +
                    "Time-dependent: ${speedLimit.timeDependentSpeedLimitInMetersPerSecond}"
        )
        return speedLimit.effectiveSpeedLimitInMetersPerSecond()
    }

    private fun setupRouteProgressListener(navInstance: Any) {
        val progressListener = RouteProgressListener { routeProgress ->
            try {
                // Log navigation progress
                logNavigationProgress(routeProgress)
                
                // Update trip progress tracker
                tripProgressTracker?.onRouteProgressUpdate(routeProgress)
                
                // Send periodic MQTT updates (every 30 seconds)
                sendPeriodicMqttUpdate()
            } catch (e: Exception) {
                Log.e(TAG, "Error in route progress listener: ${e.message}", e)
            }
        }


        val navigableLocationListener = NavigableLocationListener { currentNavigableLocation: NavigableLocation ->
            try {
                val lastMapMatchedLocation = currentNavigableLocation.mapMatchedLocation
                if (lastMapMatchedLocation == null) {
                    Log.w(TAG, "No map-matched location available, You are Off-road")
                    return@NavigableLocationListener
                }
                
                if (lastMapMatchedLocation.isDrivingInTheWrongWay) {
                    // For two-way streets, this value is always false. This feature is supported in tracking mode and when deviating from a route.
                    Log.d(
                        TAG,
                        "This is a one way road. User is driving against the allowed traffic direction."
                    )
                }
                
                val speed = currentNavigableLocation.originalLocation.speedInMetersPerSecond ?: 0.0
                val accuracy = currentNavigableLocation.originalLocation.speedAccuracyInMetersPerSecond ?: 0.0
                Log.d(
                    TAG,
                    "Driving speed (m/s): $speed plus/minus an accuracy of: $accuracy"
                )
                
                // Update speed display if showing map
                if (showMap) {
                    updateSpeedFromLocation(currentNavigableLocation.originalLocation)
                }
                
                // Update trip progress tracker with current speed and position
                tripProgressTracker?.updateCurrentSpeedAndPosition(
                    speedInMetersPerSecond = speed,
                    speedAccuracyInMetersPerSecond = accuracy,
                    location = currentNavigableLocation.originalLocation
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error in navigable location listener: ${e.message}", e)
            }
        }

        val routeDeviationListener = RouteDeviationListener { routeDeviation ->
            try {
                handleRouteDeviation(routeDeviation)
            } catch (e: Exception) {
                Log.e(TAG, "Error in route deviation listener: ${e.message}", e)
            }
        }

        when (navInstance) {
            is VisualNavigator -> {
                navInstance.routeProgressListener = progressListener
                navInstance.navigableLocationListener = navigableLocationListener
                navInstance.routeDeviationListener = routeDeviationListener
                Log.d(TAG, "Route deviation listener set up for VisualNavigator")
            }
            is Navigator -> {
                navInstance.routeProgressListener = progressListener
                navInstance.navigableLocationListener = navigableLocationListener
                navInstance.routeDeviationListener = routeDeviationListener
                Log.d(TAG, "Route deviation listener set up for headless Navigator")
            }
        }
    }

    private fun handleRouteDeviation(routeDeviation: RouteDeviation) {
        val route = currentRoute
        if (route == null) {
            Log.w(TAG, "No current route available for deviation handling")
            return
        }

        // Get current geographic coordinates
        val currentMapMatchedLocation = routeDeviation.currentLocation.mapMatchedLocation
        val currentGeoCoordinates = currentMapMatchedLocation?.coordinates 
            ?: routeDeviation.currentLocation.originalLocation.coordinates

        // Get last geographic coordinates on route
        // Get last geographic coordinates on route.
        val lastGeoCoordinatesOnRoute: GeoCoordinates?
        if (routeDeviation.lastLocationOnRoute != null) {
            val lastMapMatchedLocationOnRoute =
                routeDeviation.lastLocationOnRoute!!.mapMatchedLocation
            lastGeoCoordinatesOnRoute =
                lastMapMatchedLocationOnRoute?.coordinates
                    ?: routeDeviation.lastLocationOnRoute!!.originalLocation.coordinates
        } else {
            Log.d(
                TAG,
                "User was never following the route. So, we take the start of the route instead."
            )
            lastGeoCoordinatesOnRoute =
                route.sections[0].departurePlace.originalCoordinates
        }

        val distanceInMeters = currentGeoCoordinates.distanceTo(lastGeoCoordinatesOnRoute!!).toInt()
        Log.d(TAG, "Route deviation detected: ${distanceInMeters}m from route")

        // Count deviation events - wait for multiple events before deciding on action
        deviationCounter++

        if (isReturningToRoute) {
            Log.d(TAG, "Rerouting is already in progress, ignoring deviation event")
            return
        }

        // Check if deviation is significant enough to trigger rerouting
        if (distanceInMeters > DEVIATION_THRESHOLD_METERS && deviationCounter >= MIN_DEVIATION_EVENTS) {
            Log.d(TAG, "=== ROUTE DEVIATION DETECTED ===")
            Log.d(TAG, "Deviation distance: ${distanceInMeters}m (threshold: ${DEVIATION_THRESHOLD_METERS}m)")
            Log.d(TAG, "Deviation events: $deviationCounter (minimum: $MIN_DEVIATION_EVENTS)")
            Log.d(TAG, "Starting rerouting process...")
            
            isReturningToRoute = true
            performRerouting(routeDeviation, currentGeoCoordinates, currentMapMatchedLocation)
        } else {
            Log.d(TAG, "Deviation not significant enough for rerouting: ${distanceInMeters}m (need ${DEVIATION_THRESHOLD_METERS}m+) or not enough events: $deviationCounter (need $MIN_DEVIATION_EVENTS)")
        }
    }

    private fun resetDeviationState() {
        isReturningToRoute = false
        deviationCounter = 0
        Log.d(TAG, "Deviation state reset for new route")
    }

    private fun performRerouting(
        routeDeviation: RouteDeviation, 
        currentGeoCoordinates: GeoCoordinates, 
        currentMapMatchedLocation: com.here.sdk.navigation.MapMatchedLocation?
    ) {
        val route = currentRoute ?: return
        
        // Use current location as new starting point for the route
        val newStartingPoint = Waypoint(currentGeoCoordinates)
        
        // Improve route calculation by setting the heading direction
        currentMapMatchedLocation?.bearingInDegrees?.let { bearing ->
            newStartingPoint.headingInDegrees = bearing
            Log.d(TAG, "Setting heading direction: ${bearing}¬∞")
        }

        Log.d(TAG, "Calculating new route from current position...")
        
        // Use the return-to-route algorithm to find the fastest way back to the original route
        val routingEngine = getSelectedRoutingEngine()
        
        routingEngine.returnToRoute(
            route,
            newStartingPoint,
            routeDeviation.lastTraveledSectionIndex,
            routeDeviation.traveledDistanceOnLastSectionInMeters
        ) { routingError, routes ->
            if (routingError == null && routes != null && routes.isNotEmpty()) {
                val newRoute = routes[0]
                Log.d(TAG, "=== REROUTING SUCCESSFUL ===")
                Log.d(TAG, "New route calculated successfully")
                
                // Update current route
                currentRoute = newRoute
                
                // Update route in progress tracker
                tripProgressTracker?.setCurrentRoute(newRoute)
                
                // Update navigators with new route
                visualNavigator?.route = newRoute
                navigator?.route = newRoute
                
                // Update map display if showing map
                if (showMap) {
                    showRouteOnMap(newRoute)
                }
                
                // Log new route information
                logRouteInfo(newRoute)
                
                Log.d(TAG, "==========================")
            } else {
                Log.e(TAG, "Rerouting failed: ${routingError?.name}")
                Log.w(TAG, "Continuing with original route despite deviation")
            }
            
            // Reset flags and counter
            isReturningToRoute = false
            deviationCounter = 0
            Log.d(TAG, "Rerouting process completed")
        }
    }

    private fun logNavigationProgress(routeProgress: RouteProgress) {
        val maneuverProgressList = routeProgress.maneuverProgress
        if (maneuverProgressList.isNotEmpty()) {
            val nextManeuverProgress = maneuverProgressList[0]
            nextManeuverProgress?.let { progress ->
                val remainingDistance = progress.remainingDistanceInMeters / 1000.0

                val sectionProgressList = routeProgress.sectionProgress
                if (sectionProgressList.isNotEmpty()) {
                    val lastSection = sectionProgressList.last()
                    val totalRemainingDistance = lastSection.remainingDistanceInMeters / 1000.0
                    val totalRemainingTime = lastSection.remainingDuration.seconds / 60

                    Log.d(TAG, "=== NAVIGATION UPDATE ===")
                    Log.d(TAG, "Next maneuver: ${String.format("%.2f", remainingDistance)} km")
                    Log.d(
                        TAG,
                        "Total remaining: ${String.format("%.2f", totalRemainingDistance)} km"
                    )
                    Log.d(TAG, "ETA: $totalRemainingTime minutes")
                    Log.d(TAG, "========================")
                }
            }
        }
    }

    private fun setupLocationSource(locationListener: LocationListener, route: Route, isSimulator: Boolean) {
        if (!isSimulator) {
            locationEngine?.let { engine ->
                Log.d(TAG, "Setting up location source for real-time navigation")
                
                // Check if location engine is already running
                try {
                    // Add the navigation-specific location listener
                    engine.addLocationListener(locationListener)
                    Log.d(TAG, "Added navigation location listener to existing location engine")
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to add location listener: ${e.message}")
                    // Fallback to simulated navigation if GPS fails
                    Log.w(TAG, "Falling back to simulated navigation due to GPS failure")
                    isSimulated = true
                    isNavigationStarted = true
                    calculateRouteAndStartNavigation()
                }
            } ?: run {
                Log.w(TAG, "Location engine not available, falling back to simulated navigation")
                isSimulated = true
                isNavigationStarted = true
                calculateRouteAndStartNavigation()
            }
        } else {
            try {
                locationSimulator = LocationSimulator(route, LocationSimulatorOptions())
            } catch (e: InstantiationErrorException) {
                Log.e(TAG, "Initialization of LocationSimulator failed: ${e.error.name}")
                throw RuntimeException("Initialization of LocationSimulator failed: " + e.error.name)
            }

            locationSimulator?.let { simulator ->
                simulator.listener = locationListener
                simulator.start()
                Log.d(TAG, "Location simulation started")
            }
        }
    }

    fun refreshNetworkStatus() {
        Log.d(TAG, "=== REFRESHING NETWORK STATUS ===")
        Log.d(TAG, "Current state: Connected=$isNetworkConnected, Type=$currentConnectionType, Metered=$isConnectionMetered")
        
        // Use current state instead of re-scanning
        recommendRoutingStrategy(isNetworkConnected, isConnectionMetered)
        
        // Only check for actual changes via network monitor
        networkMonitor?.getCurrentNetworkState()?.let { state ->
            if (state.isConnected != isNetworkConnected || 
                state.connectionType != currentConnectionType || 
                state.isMetered != isConnectionMetered) {
                Log.d(TAG, "Network state changed during refresh, updating...")
                handleNetworkStateChange(state.isConnected, state.connectionType, state.isMetered)
            } else {
                Log.d(TAG, "No network state change detected during refresh")
            }
        }
        Log.d(TAG, "===============================")
    }

    fun cancelMapDownloads() {
        for (task in mapDownloaderTasks) {
            task.cancel()
        }
        Log.d(TAG, "Cancelled ${mapDownloaderTasks.size} download tasks")
        mapDownloaderTasks.clear()
    }

    /**
     * Handle camera toggle button press from XML layout
     */
    fun onCameraTogglePressed(view: android.view.View) {
        if (showMap && visualNavigator != null) {
            isCameraBehaviorEnabled = !isCameraBehaviorEnabled
            
            if (isCameraBehaviorEnabled) {
                visualNavigator?.cameraBehavior = DynamicCameraBehavior()
                Log.d(TAG, "Camera behavior enabled - Dynamic camera behavior active")
            } else {
                visualNavigator?.cameraBehavior = null
                Log.d(TAG, "Camera behavior disabled - Free camera mode")
            }
            
            // Update button text to reflect current state
            val button = findViewById<android.widget.Button>(R.id.cameraToggleButton)
            button.text = if (isCameraBehaviorEnabled) "Free Camera" else "Auto Camera"
        }
    }

    /**
     * Handle back button press from XML layout
     */
    fun onBackPressed(view: android.view.View) {
        Log.d(TAG, "Back button pressed, finishing Navigator activity")
        finish()
    }

    override fun onDestroy() {
        super.onDestroy()
        
        isDestroyed = true
        isShowingBookingConfirmation = false
        isProcessingNFC = false
        pendingNFCId = null

        Log.d(TAG, "Stopping network monitoring...")
        networkMonitor?.stopMonitoring()
        offlineSwitchRunnable?.let {
            handler.removeCallbacks(it)
        }

        handler.removeCallbacksAndMessages(null)
        stopCurrentNavigation()

        // Reset trip progress tracker
        tripProgressTracker?.reset()

        // Clean up speed display
        resetSpeedDisplay()

        // Clean up booking confirmation
        confirmationRunnable?.let { handler.removeCallbacks(it) }
        confirmationRunnable = null
        
        bookingConfirmationView?.let { view ->
            val parent = view.parent as? android.view.ViewGroup
            parent?.removeView(view)
        }
        bookingConfirmationView = null

        // Clean up NFC reader safely
        try {
            nfcReaderHelper?.disableNfcReader(this)
        } catch (e: Exception) {
            Log.w(TAG, "Error disabling NFC reader during destroy: ${e.message}")
        }

        locationSimulator?.stop()
        dynamicRoutingEngine?.stop()
        cancelMapDownloads()

        if (showMap) {
            visualNavigator?.stopRendering()
            mapView?.onDestroy()
        }

        visualNavigator?.routeProgressListener = null
        navigator?.routeProgressListener = null
        disposeHERESDK()
    }

    private fun disposeHERESDK() {
        SDKNativeEngine.getSharedInstance()?.dispose()
        SDKNativeEngine.setSharedInstance(null)
    }

    override fun onPause() {
        super.onPause()
        if (showMap) {
            mapView?.onPause()
        } else if (!isDestroyed) {
            // Disable NFC reader in headless mode when paused (only if not destroyed)
            try {
                nfcReaderHelper?.disableNfcReader(this)
            } catch (e: Exception) {
                Log.w(TAG, "Error disabling NFC reader during pause: ${e.message}")
            }
        }
    }

    override fun onResume() {
        super.onResume()
        if (showMap) {
            mapView?.onResume()
        } else if (!isDestroyed) {
            // Re-enable NFC reader in headless mode (only if not destroyed)
            nfcReaderHelper?.let { helper ->
                if (helper.isNfcSupported() && helper.isNfcEnabled()) {
                    helper.enableNfcReader(this)
                }
            }
        }
        // Only refresh network status if we don't have initial state from MainActivity
        if (isNetworkConnected == false && currentConnectionType == "UNKNOWN") {
            Log.d(TAG, "No initial network state from MainActivity, refreshing...")
            refreshNetworkStatus()
        } else {
            Log.d(TAG, "Using network state from MainActivity, no refresh needed")
        }
    }

    // Import methods remain the same but now work with trip data context
    fun importRouteFromHandle(routeHandle: String, routeOptions: CarOptions = CarOptions()) {
        Log.d(TAG, "Importing route from handle: $routeHandle")

        onlineRoutingEngine?.importRoute(
            RouteHandle(routeHandle),
            RefreshRouteOptions(TransportMode.CAR)
        ) { routingError, routes ->
            if (routingError == null && routes != null && routes.isNotEmpty()) {
                val importedRoute = routes[0]
                currentRoute = importedRoute

                Log.d(TAG, "Route imported successfully from handle")
                logRouteInfo(importedRoute)

                if (showMap) {
                    showRouteOnMap(importedRoute)
                }

                startGuidance(importedRoute)
            } else {
                Log.e(TAG, "Route import failed: ${routingError?.name}")
            }
        }
    }

    fun importRouteFromCoordinates(
        coordinates: List<GeoCoordinates>,
        routeOptions: CarOptions = CarOptions()
    ) {
        Log.d(TAG, "Importing route from ${coordinates.size} coordinates")

        val locations = coordinates.map { Location(it) }

        onlineRoutingEngine?.importRoute(locations, routeOptions) { routingError, routes ->
            if (routingError == null && routes != null && routes.isNotEmpty()) {
                val importedRoute = routes[0]
                currentRoute = importedRoute

                // Set route in progress tracker
                tripProgressTracker?.setCurrentRoute(importedRoute)

                Log.d(TAG, "Route imported successfully from coordinates")
                logRouteInfo(importedRoute)

                if (showMap) {
                    showRouteOnMap(importedRoute)
                }

                startGuidance(importedRoute)
            } else {
                Log.e(TAG, "Route import from coordinates failed: ${routingError?.name}")
            }
        }
    }

    // Trip progress tracking methods
    fun getCurrentTripProgress(): Map<Int, com.gocavgo.validator.dataclass.WaypointProgress>? {
        return try {
            tripProgressTracker?.getCurrentProgress()
        } catch (e: Exception) {
            Log.e(TAG, "Error getting current trip progress: ${e.message}", e)
            null
        }
    }

    fun getReachedWaypoints(): Set<Int>? {
        return try {
            tripProgressTracker?.getReachedWaypoints()
        } catch (e: Exception) {
            Log.e(TAG, "Error getting reached waypoints: ${e.message}", e)
            null
        }
    }

    @SuppressLint("DefaultLocale")
    fun getTripProgressSummary(): String {
        return try {
            val progress = tripProgressTracker?.getCurrentProgress()
            val reached = tripProgressTracker?.getReachedWaypoints()
            
            buildString {
                appendLine("=== TRIP PROGRESS SUMMARY ===")
                appendLine("Trip ID: ${tripResponse?.id}")
                appendLine("Total waypoints: ${tripResponse?.waypoints?.size}")
                appendLine("Reached waypoints: ${reached?.size ?: 0}")
                appendLine("Current progress: ${progress?.size ?: 0} waypoints tracked")
                appendLine("Deviation events: $deviationCounter")
                appendLine("Rerouting in progress: $isReturningToRoute")
                
                progress?.forEach { (waypointId, waypointProgress) ->
                    appendLine("  - ${waypointProgress.locationName}: ${String.format("%.1f", waypointProgress.remainingDistanceInMeters)}m remaining")
                    waypointProgress.currentSpeedInMetersPerSecond?.let { speed ->
                        appendLine("    Current speed: ${String.format("%.2f", speed)} m/s")
                    }
                    waypointProgress.currentLatitude?.let { lat ->
                        waypointProgress.currentLongitude?.let { lng ->
                            appendLine("    Position: ${String.format("%.6f", lat)}, ${String.format("%.6f", lng)}")
                        }
                    }
                }
                appendLine("=============================")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting trip progress summary: ${e.message}", e)
            "Error: Unable to get trip progress summary"
        }
    }

    private var lastMqttUpdateTime = 0L
    private val MQTT_UPDATE_INTERVAL = 30000L // 30 seconds

    /**
     * Send periodic MQTT updates to keep the backend informed of trip progress
     */
    private fun sendPeriodicMqttUpdate() {
        try {
            val currentTime = System.currentTimeMillis()
            if (currentTime - lastMqttUpdateTime > MQTT_UPDATE_INTERVAL) {
                tripProgressTracker?.sendPeriodicProgressUpdate()
                lastMqttUpdateTime = currentTime
                Log.d(TAG, "Periodic MQTT update sent")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error sending periodic MQTT update: ${e.message}", e)
        }
    }

    /**
     * Update trip status to in_progress as soon as guidance starts
     */
    private fun updateTripStatusToInProgress(callback: (Boolean) -> Unit = {}) {
        try {
            tripResponse?.let { trip ->
                val currentStatus = trip.status
                val normalizedCurrentStatus = TripStatus.normalizeStatus(currentStatus)
                val newStatus = when (normalizedCurrentStatus) {
                    TripStatus.SCHEDULED.value -> TripStatus.IN_PROGRESS.value
                    TripStatus.PENDING.value -> TripStatus.IN_PROGRESS.value
                    else -> normalizedCurrentStatus
                }
                
                if (newStatus != normalizedCurrentStatus) {
                    lifecycleScope.launch {
                        try {
                            databaseManager.updateTripStatus(trip.id, newStatus)
                            Log.d(TAG, "Trip ${trip.id} status updated from $currentStatus to $newStatus")
                            
                            // Update local trip status
                            tripResponse = trip.copy(status = newStatus)
                            
                            // Call callback with success
                            callback(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "Failed to update trip status: ${e.message}", e)
                            callback(false)
                        }
                    }
                } else {
                    Log.d(TAG, "Trip ${trip.id} already has status: $currentStatus")
                    callback(true) // Already has correct status
                }
            } ?: run {
                Log.e(TAG, "No trip response available for status update")
                callback(false)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error updating trip status to in_progress: ${e.message}", e)
            callback(false)
        }
    }
}
